```ts
declare var UserTable, A, B, C, D, E
UserTable({
    url: 'afsasf',
    events: {
        success: function(res) { console.log(res) },
        failed: function(err) { console.log(err) },
    }
}, [
    A({}, []),
    B({}, [
        C({}, [
            D({}, [])
        ])
    ])
])
// 从上面那种语法可以看出，如果单纯把子元素放在父元素外部构建，将必须把所有的子元素构建完成才能够进行比较。。。但换种写法
E({}, [
    [A, {}, []],
    [B, {}, [
        [C, {}, [
            [D, {}, []]
        ]]
    ]]
])


// 这样，ABCD 就都没有运行，只需要比较 E 的 attrs 和 E 的子元素的构造函数和属性和子元素的子元素的构造函数和属性。。。递归。。。
// 但其实，如果上面的语法中，ABCD的运行仅仅是做了一个存储操作，并没有涉及计算，那，两者其实是没差的。。。

// 但假如说换另一种激进的方式，根本没有组件的说法，无非只是函数的封装，然后只有最基本的 div input 这类原生组件
// 那些方法的定义也没必要遵守类似 div(attrs:Object, children: []Node) 这种格式
// 那这样如果要采用redux之类的模式，可能就需要这些函数是纯粹的函数式，同样的输入绝对得到同样的输出，
// 然后加上缓存结果，这样才能在每次应用状态改变时，只计算需要被改变的一条支线。。。
// 但说到底这都是得到最基本的html元素级别，然后比较虚拟dom，来改变真实dom

// 如果有组件，先假设自定义组件没有children，是根据它自己的属性自己内部生成children的。。。那么自定义组件也有update方法，自己修改自己所属的dom树，
// 则只要属性未变，就可以彻底中断这条支线
// 如果有外部children，则children应该自己管理自己，调用自己的update方法。。。
// 这里要组件有自己的update方法，则要求组件在render时能够得到自己的真实dom引用。。。。
// 不然就跟 纯粹的函数没有区别了，都需要到最基本的html元素级别进行属性比较

// 。。。所以对于纯粹函数式，返回的虚拟dom在渲染进真实dom时能得到自己渲染出来的真实dom的引用就可以解决各种问题。。
```